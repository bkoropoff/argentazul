#!/bin/sh -eu
APPNAME=${0##*/}
CACHEDIR="${XDG_CACHE_HOME:-$HOME/.cache}/$APPNAME"
STATEDIR="${XDG_STATE_HOME:-$HOME/.local/state}/$APPNAME"
[ -z "${FORCE:-}" ] && FORCE=false
[ -z "${CONTAINERFILE:-}" ] && CONTAINERFILE=
[ -z "${CONFIGDIR:-}" ] && CONFIGDIR=

# Find configuation files in XDG paths
find_config()
{
    sub=""
    [ -n "$TOOLBOX" ] && sub="/$TOOLBOX"
    _IFS="$IFS"
    IFS=:
    set -- ${XDG_CONFIG_HOME:-$HOME/.config} ${XDG_CONFIG_DIRS}
    IFS="$_IFS"
    for dir
    do
        [ -z "$dir" ] && continue
        [ -z "$CONFIGDIR" -a -d "$dir/$APPNAME$sub" ] && CONFIGDIR="$dir/$APPNAME$sub"

        if [ -f "$dir/$APPNAME$sub/config" ]
        then
            . "$dir/$APPNAME$sub/config"
        fi
        if [ -z "$CONTAINERFILE" -a -f "$dir/$APPNAME$sub/Containerfile" ]
        then
            CONTAINERFILE="$dir/$APPNAME$sub/Containerfile"
        fi
    done
}

usage()
{
    echo "Usage:"
    echo "  $APPNAME [-f|--force] [-c|--config FILE] [--distro DISTRO] [--toolbox TOOLBOX] [purge|update]"
    echo ""
    echo "Description:"
    echo "  Update and customize Fedora atomic distributions"
}

help()
{
    usage
    echo ""
    echo "Commands:"
    echo "  update                  Build and deploy any updates (default)"
    echo "  purge                   Clean intermediate containers and images"
    echo ""
    echo "Options:"
    echo "  -f, --force             Build and deploy image even without update"
    echo "  -c FILE, --config FILE  Read an additional configuration file"
    echo "  --distro DISTRO         Override distribution"
    echo "  --release RELEASE       Override release"
    echo "  --toolbox TOOLBOX       Build and deploy the toolbox container of the given name"
    echo "                          instead of the host system. An argument of \`default\`"
    echo "                          specifies the default toolbox container."
    echo ""
    echo "Environment and configuration file variables:"
    echo "  TOOLBOX                 Toolbox container to operate on (${TOOLBOX:-unset})"
    echo "  REGISTRY                Registry to use (${REGISTRY:-unset})"
    echo "  DISTRO                  Distribution variant to use (${DISTRO:-unset})"
    echo "  RELEASE                 Distribution release to use (${RELEASE:-unset})"
    echo "  FORCE                   Build and deploy image even without update ($FORCE)"
    echo "  CONFIGDIR               Main configuration directory ($CONFIGDIR)"
    echo "  CONTAINERFILE           Partial Containerfile to use (${CONTAINERFILE:-unset})"
}

# Get ID of local copy of base image
# result: the ID
current_image()
{
    result=`buildah inspect -t image --format '{{.FromImageID}}' "$FROM" 2>/dev/null` || result="none"
}

# Update base image from registry
# return:
#   true: update available
#   false: no update available
update()
{
    current_image
    prev="$result"
    updated=`buildah pull --policy=ifnewer $FROM`
    [ "$prev" != "$updated" ]
}

# Clean up stale containers and images
purge()
{
    echo "Purging containers and images"
    for entry in `buildah containers --format '{{.ContainerID}},{{.ImageID}}'`
    do
        cid=${entry%,*}
        iid=${entry#*,}
        if [ "$(buildah inspect --format "{{.OCIv1.Config.Labels.${APPNAME}_distro}}" "$cid")" = "$DISTRO" ]
        then
            buildah rm "$cid"
            buildah rmi -f "$iid"
        fi
    done
    # Remove any images left dangling by the above
    set -- `buildah images -a -f dangling=true --format '{{.ID}}' 2>/dev/null`
    [ "$#" -gt 0 ] && buildah rmi -f "$@"
    true
}

TOOLBOX="${TOOLBOX:-}"
COMMAND=update

while [ $# -gt 0 ]
do
    case "$1" in
        -c|--config)
            . "$(realpath "$2")"
            shift 2
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        --distro)
            DISTRO="$2"
            shift 2
            ;;
        --release)
            RELEASE="$2"
            shift 2
            ;;
        --toolbox)
            TOOLBOX="$2"
            shift 2
            ;;
        -h|--help)
            COMMAND=help
            shift
            ;;
        purge)
            COMMAND=purge
            shift
            ;;
        update)
            COMMAND=update
            shift
            ;;
        --*|-*|*)
            usage
            exit 1
            ;;
    esac
done

if [ -z "${REGISTRY:-}" ]
then
    case "$TOOLBOX" in
        "") REGISTRY=quay.io/fedora-ostree-desktops ;;
        *) REGISTRY=registry.fedoraproject.org ;;
    esac
fi

if [ -e /usr/lib/os-release ]
then
    eval "`/bin/grep -E '^ID=|^VARIANT_ID=|^VERSION_ID=' /usr/lib/os-release`"
    if [ -z "${DISTRO:-}" ]
    then
        if [ -z "$TOOLBOX" ]
        then
            DISTRO="$VARIANT_ID"
        else
            DISTRO="fedora-toolbox"
        fi
    fi

    [ -z "${RELEASE:-}" ] && RELEASE="$VERSION_ID"
    unset ID VARIANT_ID VERSION_ID
fi

[ "$TOOLBOX" = "default" ] && TOOLBOX="$DISTRO-$RELEASE"

find_config

UPDATESTAMP="${STATEDIR}/update-stamp"
[ -n "$TOOLBOX" ] && UPDATESTAMP="$UPDATESTAMP-$TOOLBOX"

if [ -n "$TOOLBOX" ]
then
    WORKDIR="$CACHEDIR/work-$TOOLBOX"
else
    WORKDIR=/var/cache/$APPNAME
fi

FROM=$REGISTRY/$DISTRO:$RELEASE
TIMESTAMP=`date -u +%F-%H%M%S`

if [ -n "$TOOLBOX" ]
then
    OUTPUT=""
    TAG=$APPNAME-toolbox-$TOOLBOX
else
    OUTPUT=${WORKDIR}/${DISTRO}-${RELEASE}-${TIMESTAMP}.tar
    TAG=oci-archive:"$OUTPUT"
fi

if [ $COMMAND = help ]
then
    help
    exit 0
fi

if [ $COMMAND = purge ]
then
    purge
    exit 0
fi

# Check for update
if update
then
    # Create stamp indicating rebuild is needed
    mkdir -p "$STATEDIR"
    touch "$UPDATESTAMP"
    # Purge old containers/images invalidated by update
    purge
fi

if [ ! -e "$UPDATESTAMP" -a "$FORCE" != "true" ]
then
    echo "No updates available"
    exit 0
fi

# Create work directory with sudo if necessary
if [ ! -d "$WORKDIR" ] && ! mkdir -p "$WORKDIR" >/dev/null 2>&1
then
    echo "Need to create $WORKDIR"
    sudo sh -c "mkdir -m 0775 '$WORKDIR'; chgrp wheel '$WORKDIR'"
fi

trap 'rm -f "$OUTPUT" "$WORKDIR"/Containerfile' EXIT

{
    cat <<EOF
FROM $FROM
LABEL ${APPNAME}_distro=$DISTRO ${APPNAME}_release=$RELEASE
ARG REGISTRY=$REGISTRY DISTRO=$DISTRO RELEASE=$RELEASE FROM=$FROM HOSTNAME=${HOSTNAME:-`hostname`}
EOF
    if [ -n "$TOOLBOX" ]
    then
        cat <<EOF
ARG TOOLBOX=$TOOLBOX
EOF
    fi

    cat "$CONTAINERFILE"
} > "$WORKDIR/Containerfile"

TMPDIR="$CACHEDIR/tmp-$DISTRO-$RELEASE"
mkdir -p "$TMPDIR"

# Build the image
env TMPDIR="$TMPDIR" buildah build \
        -t "$TAG" \
        --layers \
        --pull=never \
        --net=slirp4netns \
        -f "$WORKDIR/Containerfile" \
        "$CONFIGDIR"

# Install the image
if [ -n "$TOOLBOX" ]
then
    podman rm -if "$TOOLBOX" >/dev/null 2>&1
    toolbox create --image "$TAG" "$TOOLBOX"
else
    rpm-ostree rebase ostree-unverified-image:"$TAG"
fi

# Clear stamp indicating rebuild needed
rm -f "$UPDATESTAMP"
